<!DOCTYPE html>
<html>
<head>
    <title>Chess Engine WASM Test - Part 4</title>
    <style>
        body {
            font-family: monospace;
            background: #1a1a2e;
            color: #0f0;
            padding: 20px;
        }
        #output {
            white-space: pre-wrap;
            background: #0d0d1a;
            padding: 20px;
            border-radius: 8px;
            border: 1px solid #333;
            max-height: 80vh;
            overflow-y: auto;
        }
        h1 { color: #f39c12; }
        .success { color: #2ecc71; }
        .error { color: #e74c3c; }
        .info { color: #3498db; }
        .move { color: #9b59b6; }
        .eval { color: #e67e22; }
    </style>
</head>
<body>
    <h1>ðŸ¦€ Rust Chess Engine - Part 4: Search & Evaluation</h1>
    <div id="output">Loading...</div>

    <script type="module">
        const output = document.getElementById('output');
        
        function log(msg, type = '') {
            const span = document.createElement('span');
            span.className = type;
            span.textContent = msg + '\n';
            output.appendChild(span);
        }
        
        function clearOutput() {
            output.innerHTML = '';
        }

        async function runTests() {
            clearOutput();
            log('=== Chess Engine WASM Test - Part 4: Search & Evaluation ===\n', 'info');
            
            try {
                // Import and initialize WASM module
                log('Loading WASM module...', 'info');
                const wasm = await import('./wasm/chess_engine.js');
                await wasm.default();
                log('âœ… WASM module loaded!\n', 'success');
                
                // Test ping and info
                log(`${wasm.ping()}`, 'success');
                log(`\n${wasm.engine_info()}`, 'info');
                
                // === EVALUATION TESTS ===
                log('\n=== EVALUATION TESTS ===', 'info');
                
                // Starting position
                let pos = wasm.new_game();
                let evalScore = wasm.eval_position(pos);
                log(`Starting position eval: ${evalScore} cp`, 'eval');
                log(`(Should be ~0, balanced position)`, evalScore === 0 || Math.abs(evalScore) < 50 ? 'success' : 'error');
                
                // Material advantage
                const queenUpPos = wasm.from_fen('rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNB1KBNR w KQkq - 0 1');
                evalScore = wasm.eval_position(queenUpPos);
                log(`\nWhite missing queen: ${evalScore} cp`, 'eval');
                log(`(Should be ~-900, black up a queen)`, evalScore < -800 ? 'success' : 'error');
                
                // === SEARCH TESTS ===
                log('\n=== SEARCH TESTS ===', 'info');
                
                // Best move in starting position
                log('\nSearching starting position (depth 3)...', 'info');
                pos = wasm.new_game();
                let result = wasm.search_position(pos, 3);
                log(`Best move: ${result.best_move}`, 'move');
                log(`Score: ${result.score} cp`, 'eval');
                log(`Nodes searched: ${result.nodes}`, 'success');
                log(`Depth: ${result.depth}`, 'success');
                
                // Find free queen
                log('\n--- Tactic Test: Capture Free Queen ---', 'info');
                const freeQueenPos = wasm.from_fen('7k/8/8/8/4q3/8/4R3/4K3 w - - 0 1');
                result = wasm.search_position(freeQueenPos, 4);
                log(`Position: Rook on e2, Black queen on e4 (undefended)`, 'info');
                log(`Best move: ${result.best_move}`, 'move');
                log(`Expected: e2e4 (Rxe4)`, result.best_move === 'e2e4' ? 'success' : 'error');
                log(`Score: ${result.score} cp (should be high - winning queen)`, 'eval');
                
                // Avoid losing queen
                log('\n--- Tactic Test: Avoid Losing Piece ---', 'info');
                const escapePos = wasm.from_fen('7k/8/8/8/3r4/8/3Q4/4K3 w - - 0 1');
                result = wasm.search_position(escapePos, 3);
                log(`Position: White queen attacked by rook`, 'info');
                log(`Best move: ${result.best_move}`, 'move');
                const goodMoves = ['d2d1', 'd2e2', 'd2c2', 'd2b2', 'd2a2', 'd2d3', 'd2e3', 'd2f4', 'd2g5', 'd2h6', 'd2c3', 'd2c1', 'd2d4'];
                log(`Queen escapes or captures: ${goodMoves.includes(result.best_move) || result.best_move === 'd2d4'}`, 
                    goodMoves.includes(result.best_move) || result.best_move === 'd2d4' ? 'success' : 'error');
                
                // Italian game opening
                log('\n--- Opening Position Test ---', 'info');
                const italianPos = wasm.from_fen('r1bqkb1r/pppp1ppp/2n2n2/4p3/2B1P3/5N2/PPPP1PPP/RNBQK2R w KQkq - 4 4');
                result = wasm.search_position(italianPos, 4);
                log(`Italian Game position`, 'info');
                log(`Best move: ${result.best_move}`, 'move');
                log(`Score: ${result.score} cp`, 'eval');
                log(`Nodes: ${result.nodes}`, 'success');
                
                // === ITERATIVE DEEPENING ===
                log('\n=== ITERATIVE DEEPENING TEST ===', 'info');
                pos = wasm.new_game();
                const startTime = performance.now();
                const bestMove = wasm.get_best_move_iterative(pos, 4);
                const elapsed = performance.now() - startTime;
                log(`Best move (iterative depth 4): ${bestMove}`, 'move');
                log(`Time: ${elapsed.toFixed(2)}ms`, 'success');
                
                // === PERFORMANCE BENCHMARKS ===
                log('\n=== PERFORMANCE BENCHMARKS ===', 'info');
                
                // Benchmark 1: Simple position
                pos = wasm.new_game();
                let start = performance.now();
                for (let i = 0; i < 10; i++) {
                    wasm.search_position(pos, 3);
                }
                let time = performance.now() - start;
                log(`Starting position depth 3: ${(time/10).toFixed(2)}ms avg`, 'success');
                
                // Benchmark 2: Midgame position
                const midgamePos = wasm.from_fen('r1bq1rk1/ppp2ppp/2np1n2/2b1p3/2B1P3/2NP1N2/PPP2PPP/R1BQ1RK1 w - - 0 7');
                start = performance.now();
                for (let i = 0; i < 10; i++) {
                    wasm.search_position(midgamePos, 3);
                }
                time = performance.now() - start;
                log(`Midgame position depth 3: ${(time/10).toFixed(2)}ms avg`, 'success');
                
                // Benchmark 3: Deep search
                pos = wasm.new_game();
                start = performance.now();
                result = wasm.search_position(pos, 5);
                time = performance.now() - start;
                log(`\nDeep search (depth 5): ${time.toFixed(2)}ms`, 'success');
                log(`Nodes: ${result.nodes}`, 'success');
                log(`NPS: ${Math.round(result.nodes / (time / 1000))} nodes/sec`, 'success');
                
                // === PLAY A GAME ===
                log('\n=== AI VS AI DEMO (5 moves each) ===', 'info');
                pos = wasm.new_game();
                for (let i = 0; i < 10; i++) {
                    const move = wasm.get_best_move(pos, 3);
                    if (!move) {
                        log(`Game over!`, 'success');
                        break;
                    }
                    const side = i % 2 === 0 ? 'White' : 'Black';
                    wasm.make_move_uci(pos, move);
                    log(`${Math.floor(i/2) + 1}${i % 2 === 0 ? '.' : '...'} ${move}`, 'move');
                }
                log(`\nFinal position: ${wasm.to_fen(pos)}`, 'info');
                
                log('\n=== ALL PART 4 TESTS COMPLETE! ===', 'success');
                log('\nðŸŽ‰ Full chess engine working!', 'success');
                log('âœ… Bitboard representation', 'success');
                log('âœ… Magic bitboards for sliding pieces', 'success');
                log('âœ… Full legal move generation', 'success');
                log('âœ… Position evaluation (material + PST)', 'success');
                log('âœ… Alpha-beta search with quiescence', 'success');
                log('âœ… MVV-LVA move ordering', 'success');
                log('âœ… Iterative deepening', 'success');
                log('\nâ­ï¸  Part 5 will add: TypeScript integration (replace learningAI)', 'info');
                
            } catch (error) {
                log(`\nâŒ ERROR: ${error.message}`, 'error');
                log(error.stack, 'error');
            }
        }
        
        runTests();
    </script>
</body>
</html>
